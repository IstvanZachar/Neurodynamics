/* Implementation of the ran4 algorithm from Numerical Recipes in C, 2nd edition */
/* Returns a uniform random deviate in the range 0.0 to 1.0, generated by pseudo-DES (DESlike)
hashing of the 64-bit word (`idums`, `idum`), where `idums` was set by a previous call with negative `idum`.
Also increments `idum`. Routine can be used to generate a random sequence by successive calls, leaving
`idum` unaltered between calls; or it can randomly access the n.th deviate in a sequence by calling
with `idum = n`. Different sequences are initialized by calls with differing negative values of `idum`. */


#include <stdio.h>  // using: `printf`
#include <stdlib.h> // using: `exit`


#define NITER 4

static unsigned long idums = 0;
	
void psdes(unsigned long *lword, unsigned long *irword) { // “Pseudo-DES” hashing of the 64-bit word(lword,irword). Both 32-bit arguments are returned hashed on all bits.
	unsigned long i, ia, ib, iswap, itmph = 0, itmpl = 0;
	static unsigned long c1[NITER] = {0xbaa96887L, 0x1e17d32cL, 0x03bcdc3cL, 0x0f33d1b2L};
	static unsigned long c2[NITER] = {0x4b0f3b58L, 0xe874f0c3L, 0x6955c5a6L, 0x55a7ca46L};
	for (i = 0; i < NITER; i++) { // Perform n iteriterations of DES logic, using a simpler (non-cryptographic) nonlinear function instead of DES’s.
		ia = (iswap = (*irword)) ^ c1[i]; // The bit-rich constants c1 and (below) c2 guarantee lots of nonlinear mixing.
		itmpl = ia & 0xffff;
		itmph = ia >> 16;
		ib = itmpl*itmpl+ ~(itmph*itmph);
		*irword = (*lword) ^ (((ia = (ib >> 16) |
		((ib & 0xffff) << 16)) ^ c2[i]) + itmpl*itmph);
		*lword = iswap;
	}
}

float ran4(unsigned long *idum) { // `ran4` algorithm modified from "Numerical Recipes in C, 2nd ed." p.303
	// The original code used hackish type-punning that is not guaranteed to be portable;
	// here an appropriate `union` structure is used instead to eliminate all warnings.
	// Also, original code used lower half of `long` domain (negative values) to reseed `ran4`;
	// here, there is a dedicated `seedRan4` function that accepts any `unsigned long` (except 0) as
	// seed (storing in `idums`) and can accordingly return a different float for each integer `idum`
	// in the whole domain of `unsigned long`.
	union {
		unsigned long itemp;
		float ftemp;
  }u;
  unsigned long lword, rword;
  static unsigned long jflone = 0x3f800000;
  static unsigned long jflmsk = 0x007fffff;

	rword = (*idum);   
	lword = idums;
	//printf("%lu\t%lu\t%lu\t", *idum, lword, rword);
	psdes(&lword, &rword); // “Pseudo-DES” encode the words.
	//printf("%lx\t%lx\t", lword, rword);
	u.itemp = jflone | (jflmsk & rword); // Mask to a floating number between 1 and 2.
	++(*idum);
	return((u.ftemp)-1.0); // Subtraction moves range to 0. to 1.
}

void seedRan4(unsigned long *idum) { // seed random generator
	if((*idum) == 0) {printf("ERROR! Seed cannot be zero!"); exit(1);}
	// Reset `idums` to specific seed `idum` and prepare to return the first deviate in its sequence.
	idums = (*idum);
	*idum = 1; // any subsequent call of `ran4(idum)` will return an `idum`-specific result and increment the value of `idum`
	//printf("idum = %lu\n", *idum);
}

float nthRan4(unsigned long n) { // returns the n^th random number in the pseudorandom sequence of the existing seed
	unsigned long l = n; // use dummy `l` so that `n` is not incremented
	//printf("SEED = %lu ", l);
	return(ran4(&l));
}

float seededNthRan4(unsigned long seed, unsigned long n) { // returns the n^th random number in the pseudorandom sequence specific to the provided seed
	unsigned long l = seed;
	seedRan4(&l);
	return(nthRan4(n));
}
